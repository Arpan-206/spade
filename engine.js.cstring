"let setTimeout, setInterval, clearInterval, clearTimeout;\n"
"const {\n"
"  /* sprite interactions */ setSolids, setPushables,\n"
"  /*              see also: sprite.x +=, sprite.y += */\n"
"\n"
"  /* art */ setLegend, setBackground,\n"
"  /* text */ addText, clearText,\n"
"\n"
"  /*   spawn sprites */ setMap, addSprite,\n"
"  /* despawn sprites */ clearTile, /* sprite.remove() */\n"
"\n"
"  /* tile queries */ getGrid, getTile, getFirst, getAll, tilesWith,\n"
"  /* see also: sprite.type */\n"
"\n"
"  /* map dimensions */ width, height,\n"
"\n"
"  /* constructors */ bitmap, tune, map, color,\n"
"\n"
"  /* input handling */ onInput, afterInput,\n"
"\n"
"  /* how much sprite has moved since last onInput: sprite.dx, sprite.dy */\n"
"\n"
"  playTune,\n"
"} = (() => {\n"
"const exports = {};\n"
"/* re-exports from C; bottom of module_native.c has notes about why these are in C */\n"
"exports.setMap = map => native.setMap(map.trim());\n"
"exports.addSprite = native.addSprite;\n"
"exports.getGrid = native.getGrid;\n"
"exports.getTile = native.getTile;\n"
"exports.tilesWith = native.tilesWith;\n"
"exports.clearTile = native.clearTile;\n"
"exports.getFirst = native.getFirst;\n"
"exports.getAll = native.getAll;\n"
"exports.width = native.width;\n"
"exports.height = native.height;\n"
"exports.setBackground = native.setBackground;\n"
"\n"
"\n"
"/* opts: x, y, color (all optional) */\n"
"exports.addText = (str, opts={}) => {\n"
"  // console.log(\"engine.js:addText\");\n"
"  const CHARS_MAX_X = 21;\n"
"  const padLeft = Math.floor((CHARS_MAX_X - str.length)/2);\n"
"\n"
"  native.text_add(\n"
"    str,\n"
"    opts.color ?? [10, 10, 40],\n"
"    opts.x ?? padLeft,\n"
"    opts.y ?? 0\n"
"  );\n"
"}\n"
"\n"
"exports.clearText = () => native.text_clear();\n"
"\n"
"\n"
"exports.setLegend = (...bitmaps) => {\n"
"  // console.log(\"engine.js:setLegend\");\n"
"  native.legend_clear();\n"
"  for (const [charStr, bitmap] of bitmaps) {\n"
"    native.legend_doodle_set(charStr, bitmap.trim());\n"
"  }\n"
"  native.legend_prepare();\n"
"};\n"
"\n"
"exports.setSolids = solids => {\n"
"  // console.log(\"engine.js:setSolids\");\n"
"  native.solids_clear();\n"
"  solids.forEach(native.solids_push);\n"
"};\n"
"\n"
"exports.setPushables = pushTable => {\n"
"  // console.log(\"engine.js:setPushables\");\n"
"  native.push_table_clear();\n"
"  for (const [pusher, pushesList] of Object.entries(pushTable))\n"
"    for (const pushes of pushesList)\n"
"      native.push_table_set(pusher, pushes);\n"
"};\n"
"\n"
"let afterInputs = [];\n"
"// exports.afterInput = fn => (console.log('engine.js:afterInputs'), afterInputs.push(fn));\n"
"exports.afterInput = fn => afterInputs.push(fn);\n"
"\n"
"const button = {\n"
"  pinToHandlers: {\n"
"     \"5\": [],\n"
"     \"7\": [],\n"
"     \"6\": [],\n"
"     \"8\": [],\n"
"    \"12\": [],\n"
"    \"14\": [],\n"
"    \"13\": [],\n"
"    \"15\": [],\n"
"  },\n"
"  keyToPin: {\n"
"    \"w\":  \"5\",\n"
"    \"s\":  \"7\",\n"
"    \"a\":  \"6\",\n"
"    \"d\":  \"8\",\n"
"    \"i\": \"12\",\n"
"    \"k\": \"14\",\n"
"    \"j\": \"13\",\n"
"    \"l\": \"15\",\n"
"  }\n"
"};\n"
"\n"
"native.press_cb(pin => {\n"
"  button.pinToHandlers[pin].forEach(f => f());\n"
"\n"
"  afterInputs.forEach(f => f());\n"
"\n"
"  native.map_clear_deltas();\n"
"});\n"
"\n"
"{\n"
"  const timers = [];\n"
"  let id = 0;\n"
"  setTimeout  = (fn, ms) => (timers.push({ fn, ms, id }), id++);\n"
"  setInterval = (fn, ms) => (timers.push({ fn, ms, id, restartAt: ms }), id++);\n"
"  clearTimeout = clearInterval = id => {\n"
"    timers.splice(timers.findIndex(t => t.id == id), 1);\n"
"  };\n"
"  native.frame_cb(dt => {\n"
"    const errors = [];\n"
"\n"
"    for (const tim of [...timers]) {\n"
"      if (!timers.includes(tim)) continue; /* just in case :) */\n"
"\n"
"      if (tim.ms <= 0) {\n"
"        /* trigger their callback */\n"
"        try {\n"
"          tim.fn();\n"
"        } catch (error) {\n"
"          if (error) errors.push(error);\n"
"        }\n"
"\n"
"        /* restart intervals, clear timeouts */\n"
"        if (tim.restartAt !== undefined)\n"
"          tim.ms = tim.restartAt;\n"
"        else\n"
"          timers.splice(timers.indexOf(tim), 1);\n"
"      }\n"
"      tim.ms -= dt;\n"
"    }\n"
"\n"
"    /* we'll never need to throw more than one error -ced */\n"
"    if (errors.length > 0) throw errors[0];\n"
"  });\n"
"}\n"
"\n"
"exports.onInput = (key, fn) => {\n"
"  // console.log(\"engine.js:onInput\");\n"
"  const pin = button.keyToPin[key];\n"
"\n"
"  if (pin === undefined)\n"
"    throw new Error(`the sprig doesn't have a \"${key}\" button!`);\n"
"\n"
"  button.pinToHandlers[pin].push(fn);\n"
"};\n"
"\n"
"exports.playTune = () => {};\n"
"\n"
"function _makeTag(cb) {\n"
"  return (strings, ...interps) => {\n"
"    if (typeof strings === \"string\") {\n"
"      throw new Error(\"Tagged template literal must be used like name`text`, instead of name(`text`)\");\n"
"    }\n"
"    const string = strings.reduce((p, c, i) => p + c + (interps[i] ?? ''), '');\n"
"    return cb(string);\n"
"  }\n"
"}\n"
"exports.bitmap = _makeTag(text => text);\n"
"exports.tune = _makeTag(text => text);\n"
"exports.map = _makeTag(text => text);\n"
"exports.color = _makeTag(text => text);\n"
"\n"
"// .at polyfill\n"
"function at(n) {\n"
"	// ToInteger() abstract op\n"
"	n = Math.trunc(n) || 0;\n"
"	// Allow negative indexing from the end\n"
"	if (n < 0) n += this.length;\n"
"	// OOB access is guaranteed to return undefined\n"
"	if (n < 0 || n >= this.length) return undefined;\n"
"	// Otherwise, this is just normal property access\n"
"	return this[n];\n"
"}\n"
"\n"
"const TypedArray = Reflect.getPrototypeOf(Int8Array);\n"
"for (const C of [Array, String, TypedArray]) {\n"
"    Object.defineProperty(C.prototype, \"at\",\n"
"                          { value: at,\n"
"                            writable: true,\n"
"                            enumerable: false,\n"
"                            configurable: true });\n"
"}\n"
"\n"
"return exports;\n"
"})();\n"
"/*\n"
"@title: Zooter\n"
"@author: PerrinPerson\n"
"*/\n"
"\n"
"const player = \"p\";\n"
"const line = \"l\";\n"
"const enemy = \"e\";\n"
"const proj = \"o\";\n"
"const bg = \"b\";\n"
"const gear = tune `\n"
"60.120240480961925,\n"
"60.120240480961925: e5-60.120240480961925 + d5^60.120240480961925,\n"
"60.120240480961925: e5^60.120240480961925 + d5/60.120240480961925,\n"
"60.120240480961925: e5/60.120240480961925 + d5-60.120240480961925,\n"
"1683.366733466934`;\n"
"const shoot = tune `\n"
"40.48582995951417: b5~40.48582995951417 + a5~40.48582995951417 + g5~40.48582995951417 + f5~40.48582995951417 + e5~40.48582995951417,\n"
"40.48582995951417: e5~40.48582995951417 + b5~40.48582995951417 + f5^40.48582995951417 + g5^40.48582995951417 + a5^40.48582995951417,\n"
"40.48582995951417: b5~40.48582995951417 + a5~40.48582995951417 + g5~40.48582995951417 + f5~40.48582995951417 + e5~40.48582995951417,\n"
"1174.089068825911`;\n"
"const die = tune `\n"
"40.48582995951417: d4^40.48582995951417 + c4-40.48582995951417 + e4^40.48582995951417 + f4-40.48582995951417,\n"
"40.48582995951417: f4-40.48582995951417 + e4^40.48582995951417 + d4^40.48582995951417 + c4-40.48582995951417,\n"
"1214.5748987854251`;\n"
"const touch = tune `\n"
"119.04761904761905: b5-119.04761904761905,\n"
"119.04761904761905: a5-119.04761904761905,\n"
"119.04761904761905: g5-119.04761904761905,\n"
"119.04761904761905: f5-119.04761904761905,\n"
"119.04761904761905: e5-119.04761904761905,\n"
"119.04761904761905: d5-119.04761904761905,\n"
"119.04761904761905: c5-119.04761904761905,\n"
"119.04761904761905: b4-119.04761904761905,\n"
"119.04761904761905: a4-119.04761904761905,\n"
"119.04761904761905: g4-119.04761904761905,\n"
"119.04761904761905: f4-119.04761904761905,\n"
"119.04761904761905: e4-119.04761904761905,\n"
"119.04761904761905: d4-119.04761904761905,\n"
"119.04761904761905: c4-119.04761904761905,\n"
"2142.857142857143`\n"
"\n"
"let score = 0;\n"
"let projActive = false;\n"
"let timers = [];\n"
"\n"
"setLegend(\n"
"  [ player, bitmap`\n"
"................\n"
"................\n"
"................\n"
"..00000000......\n"
"..0H77HHH00.....\n"
"..0H77HHHH0.....\n"
"..0C77CCCC0.....\n"
"..0C77CCCC000000\n"
"..0C77CCCC000000\n"
"..0C77CCCC0.....\n"
"..0H77HHHH0.....\n"
"..0H77HHH00.....\n"
"..00000000......\n"
"................\n"
"................\n"
"................`],\n"
"  [ line, bitmap`\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........\n"
"....77..........`],\n"
"  [ enemy, bitmap`\n"
".........L.LL...\n"
"........L.L.L...\n"
"........LLLL....\n"
"........44444...\n"
"........40404...\n"
"........44444...\n"
"........46664...\n"
"........44444...\n"
"......LLLL55....\n"
"..........55....\n"
"......LLLL55....\n"
"..........55....\n"
".........5555...\n"
".........5..5...\n"
".........5..5...\n"
".........5..5...`],\n"
"  [ proj, bitmap`\n"
"................\n"
"................\n"
"................\n"
"................\n"
"................\n"
"................\n"
"................\n"
"......L0........\n"
"......0L0.......\n"
"......L0........\n"
"................\n"
"................\n"
"................\n"
"................\n"
"................\n"
"................`],\n"
"  [ bg, bitmap`\n"
"DDDDDDDDDDDDDDDD\n"
"DDDDD1DDDDD1DDDD\n"
"DDDDDDDDDDDDDDDD\n"
"DDDDDDDDDDDDDDDD\n"
"DDDDDDDDDDDDDD1D\n"
"DDD1DDDD1DDDDDDD\n"
"DDD1DDDDDDDDDDDD\n"
"DDDDDDDDDDDDDDDD\n"
"DDDDDDDDD1DDDDDD\n"
"1DDDDDD1DDDDDDDD\n"
"DDDDDDDDDDDDDDDD\n"
"DDDDDDDDDDDDDDDD\n"
"DDDDD1DDDDDDDDDD\n"
"DDD1DDDDDDDDDDDD\n"
"DDDDDDDDDD1DDDDD\n"
"DDDDDDDDDDDDDD1D`],\n"
");\n"
"\n"
"setSolids([]);\n"
"\n"
"let level = 0;\n"
"const levels = [\n"
"  map`\n"
"l.......\n"
"l.......\n"
"l.......\n"
"l.......`,\n"
"];\n"
"\n"
"setMap(levels[level]);\n"
"setBackground(bg);\n"
"addSprite(0, 0, player);\n"
"\n"
"setPushables({\n"
"    [ player ]: [],\n"
"});\n"
"\n"
"onInput(\"s\", () => {\n"
"  playTune(gear)\n"
"  getFirst(player).y += 1;\n"
"});\n"
"\n"
"onInput(\"w\", () => {\n"
"  playTune(gear)\n"
"  getFirst(player).y -= 1;\n"
"});\n"
"\n"
"onInput(\"k\", () => {\n"
"  if (projActive === false) {\n"
"      playTune(shoot)\n"
"      let p = getFirst(player);\n"
"      addSprite(p.x + 1, p.y, proj);\n"
"      projActive = true;\n"
"  }\n"
"});\n"
"\n"
"onInput(\"j\", () => {\n"
"  timers.forEach((timer) => {\n"
"    clearInterval(timer);\n"
"  });\n"
"\n"
"  getAll(proj).forEach((projObj) => {\n"
"    projObj.remove();\n"
"  });\n"
"\n"
"  projActive = false;\n"
"  \n"
"  getAll(enemy).forEach((enemyObj) => {\n"
"    enemyObj.remove();\n"
"  });\n"
"\n"
"  score = 0;\n"
"\n"
"  clearText();\n"
"  \n"
"  startgame();  \n"
"});\n"
"\n"
"function startgame() {\n"
"  // check for game over and draw score\n"
"  timers.push(setInterval(() => {\n"
"    addText(\"SCORE: \" + score, {\n"
"      x: 5,\n"
"      y: 0,\n"
"      color: color `0`\n"
"    });\n"
"    let gameover = false;\n"
"    getAll(enemy).forEach((enemyObj) => {\n"
"      if (enemyObj.x === 0) {\n"
"        gameover = true;\n"
"        return;\n"
"      }\n"
"    });\n"
"  \n"
"    if (gameover) {\n"
"      getAll(enemy).forEach((enemyObj) => {\n"
"        if (enemyObj.x != 0) {\n"
"          enemyObj.remove();\n"
"        }\n"
"      });\n"
"      playTune(touch);\n"
"    \n"
"      addText(\"R.I.P\", {\n"
"        x: 4,\n"
"        y: 6,\n"
"        color: color `5` \n"
"      });\n"
"  \n"
"      timers.forEach((timer) => {\n"
"        clearInterval(timer);\n"
"      });\n"
"    }\n"
"  }, 50));\n"
"  \n"
"  // moves the enemies\n"
"  timers.push(setInterval(() => {\n"
"    getAll(enemy).forEach((enemyObj) => {\n"
"      enemyObj.x -= 1;\n"
"    });\n"
"  }, 600));\n"
"  \n"
"  //  adds the enemies\n"
"  timers.push(setInterval(() => {\n"
"    for (let i = 0; i < 4; i += 1) {\n"
"      let dospawn =  Math.random();\n"
"      if (dospawn <= 0.35) {\n"
"        addSprite(7, i, enemy);\n"
"      }\n"
"    }\n"
"  }, 800));\n"
"  \n"
"  // projectile movement\n"
"  timers.push(setInterval(() => {    \n"
"    if (projActive) {\n"
"      getFirst(proj).x += 1\n"
"    }\n"
"  }, 100));\n"
"  \n"
"  timers.push(setInterval(() => {\n"
"    if (projActive) {\n"
"      // projectile hit end of screen\n"
"      let p = getFirst(proj);\n"
"      if (p.x === 7) {\n"
"        p.remove();\n"
"        projActive = false;\n"
"      }\n"
"    }\n"
"\n"
"    if (projActive) {\n"
"      // projectile hit enemy\n"
"      let p = getFirst(proj);\n"
"      getAll(enemy).forEach((enemyObj) => {\n"
"        if (p.x === enemyObj.x && p.y === enemyObj.y) {\n"
"          enemyObj.remove();\n"
"          playTune(die);\n"
"          p.remove();\n"
"          score += 1;\n"
"          projActive = false;\n"
"          return;\n"
"        }\n"
"      });\n"
"    }\n"
"  }, 20));\n"
"}\n"
"\n"
"startgame();\n"
