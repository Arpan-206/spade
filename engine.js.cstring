"let setTimeout, setInterval, clearInterval, clearTimeout;\n"
"const {\n"
"  /* sprite interactions */ setSolids, setPushables,\n"
"  /*              see also: sprite.x +=, sprite.y += */\n"
"\n"
"  /* art */ setLegend, setBackground,\n"
"  /* text */ addText, clearText,\n"
"\n"
"  /*   spawn sprites */ setMap, addSprite,\n"
"  /* despawn sprites */ clearTile, /* sprite.remove() */\n"
"\n"
"  /* tile queries */ getGrid, getTile, getFirst, getAll, tilesWith,\n"
"  /* see also: sprite.type */\n"
"\n"
"  /* map dimensions */ width, height,\n"
"\n"
"  /* constructors */ bitmap, tune, map, color,\n"
"\n"
"  /* input handling */ onInput, afterInput,\n"
"\n"
"  /* how much sprite has moved since last onInput: sprite.dx, sprite.dy */\n"
"\n"
"  playTune,\n"
"} = (() => {\n"
"const exports = {};\n"
"/* re-exports from C; bottom of module_native.c has notes about why these are in C */\n"
"exports.setMap = map => native.setMap(map.trim());\n"
"exports.addSprite = native.addSprite;\n"
"exports.getGrid = native.getGrid;\n"
"exports.getTile = native.getTile;\n"
"exports.tilesWith = native.tilesWith;\n"
"exports.clearTile = native.clearTile;\n"
"exports.getFirst = native.getFirst;\n"
"exports.getAll = native.getAll;\n"
"exports.width = native.width;\n"
"exports.height = native.height;\n"
"exports.setBackground = native.setBackground;\n"
"\n"
"\n"
"/* opts: x, y, color (all optional) */\n"
"exports.addText = (str, opts={}) => {\n"
"  // console.log(\"engine.js:addText\");\n"
"  const CHARS_MAX_X = 21;\n"
"  const padLeft = Math.floor((CHARS_MAX_X - str.length)/2);\n"
"\n"
"  native.text_add(\n"
"    str,\n"
"    opts.color ?? [10, 10, 40],\n"
"    opts.x ?? padLeft,\n"
"    opts.y ?? 0\n"
"  );\n"
"}\n"
"\n"
"exports.clearText = () => native.text_clear();\n"
"\n"
"\n"
"exports.setLegend = (...bitmaps) => {\n"
"  // console.log(\"engine.js:setLegend\");\n"
"  native.legend_clear();\n"
"  for (const [charStr, bitmap] of bitmaps) {\n"
"    native.legend_doodle_set(charStr, bitmap.trim());\n"
"  }\n"
"  native.legend_prepare();\n"
"};\n"
"\n"
"exports.setSolids = solids => {\n"
"  // console.log(\"engine.js:setSolids\");\n"
"  native.solids_clear();\n"
"  solids.forEach(native.solids_push);\n"
"};\n"
"\n"
"exports.setPushables = pushTable => {\n"
"  // console.log(\"engine.js:setPushables\");\n"
"  native.push_table_clear();\n"
"  for (const [pusher, pushesList] of Object.entries(pushTable))\n"
"    for (const pushes of pushesList)\n"
"      native.push_table_set(pusher, pushes);\n"
"};\n"
"\n"
"let afterInputs = [];\n"
"// exports.afterInput = fn => (console.log('engine.js:afterInputs'), afterInputs.push(fn));\n"
"exports.afterInput = fn => afterInputs.push(fn);\n"
"\n"
"const button = {\n"
"  pinToHandlers: {\n"
"     \"5\": [],\n"
"     \"7\": [],\n"
"     \"6\": [],\n"
"     \"8\": [],\n"
"    \"12\": [],\n"
"    \"14\": [],\n"
"    \"13\": [],\n"
"    \"15\": [],\n"
"  },\n"
"  keyToPin: {\n"
"    \"w\":  \"5\",\n"
"    \"s\":  \"7\",\n"
"    \"a\":  \"6\",\n"
"    \"d\":  \"8\",\n"
"    \"i\": \"12\",\n"
"    \"k\": \"14\",\n"
"    \"j\": \"13\",\n"
"    \"l\": \"15\",\n"
"  }\n"
"};\n"
"\n"
"native.press_cb(pin => {\n"
"  button.pinToHandlers[pin].forEach(f => f());\n"
"\n"
"  afterInputs.forEach(f => f());\n"
"\n"
"  native.map_clear_deltas();\n"
"});\n"
"\n"
"{\n"
"  const timers = [];\n"
"  let id = 0;\n"
"  setTimeout  = (fn, ms) => (timers.push({ fn, ms, id }), id++);\n"
"  setInterval = (fn, ms) => (timers.push({ fn, ms, id, restartAt: ms }), id++);\n"
"  clearTimeout = clearInterval = id => {\n"
"    const index = timers.findIndex(t => t.id == id);\n"
"    if (index !== -1) timers.splice(index, 1);\n"
"  };\n"
"  native.frame_cb(dt => {\n"
"    const errors = [];\n"
"\n"
"    for (const tim of [...timers]) {\n"
"      if (!timers.includes(tim)) continue; /* just in case :) */\n"
"\n"
"      if (tim.ms <= 0) {\n"
"        /* trigger their callback */\n"
"        try {\n"
"          tim.fn();\n"
"        } catch (error) {\n"
"          if (error) errors.push(error);\n"
"        }\n"
"\n"
"        /* restart intervals, clear timeouts */\n"
"        if (tim.restartAt !== undefined) {\n"
"          tim.ms = tim.restartAt;\n"
"        } else {\n"
"          const index = timers.indexOf(tim)\n"
"          if (index !== -1) timers.splice(index, 1);\n"
"        }\n"
"      }\n"
"      tim.ms -= dt;\n"
"    }\n"
"\n"
"    /* we'll never need to throw more than one error -ced */\n"
"    if (errors.length > 0) throw errors[0];\n"
"  });\n"
"}\n"
"\n"
"exports.onInput = (key, fn) => {\n"
"  // console.log(\"engine.js:onInput\");\n"
"  const pin = button.keyToPin[key];\n"
"\n"
"  if (pin === undefined)\n"
"    throw new Error(`the sprig doesn't have a \"${key}\" button!`);\n"
"\n"
"  button.pinToHandlers[pin].push(fn);\n"
"};\n"
"\n"
"exports.playTune = () => {};\n"
"\n"
"function _makeTag(cb) {\n"
"  return (strings, ...interps) => {\n"
"    if (typeof strings === \"string\") {\n"
"      throw new Error(\"Tagged template literal must be used like name`text`, instead of name(`text`)\");\n"
"    }\n"
"    const string = strings.reduce((p, c, i) => p + c + (interps[i] ?? ''), '');\n"
"    return cb(string);\n"
"  }\n"
"}\n"
"exports.bitmap = _makeTag(text => text);\n"
"exports.tune = _makeTag(text => text);\n"
"exports.map = _makeTag(text => text);\n"
"exports.color = _makeTag(text => text);\n"
"\n"
"// .at polyfill\n"
"function at(n) {\n"
"	// ToInteger() abstract op\n"
"	n = Math.trunc(n) || 0;\n"
"	// Allow negative indexing from the end\n"
"	if (n < 0) n += this.length;\n"
"	// OOB access is guaranteed to return undefined\n"
"	if (n < 0 || n >= this.length) return undefined;\n"
"	// Otherwise, this is just normal property access\n"
"	return this[n];\n"
"}\n"
"\n"
"const TypedArray = Reflect.getPrototypeOf(Int8Array);\n"
"for (const C of [Array, String, TypedArray]) {\n"
"    Object.defineProperty(C.prototype, \"at\",\n"
"                          { value: at,\n"
"                            writable: true,\n"
"                            enumerable: false,\n"
"                            configurable: true });\n"
"}\n"
"\n"
"return exports;\n"
"})();\n"
"/*\n"
"@title: Pipes Puzzle\n"
"@author: RayhanADev\n"
"*/\n"
"\n"
"/**\n"
"A Pipes Puzzle!! Use WASD to move the cursor around and\n"
"use L to rotate the pipe. The goal is to connect all the\n"
"pipes in the square. Connected pipes are indicated by a\n"
"blue background. All levels are random and solvable!\n"
"\n"
"GLHF :D\n"
"\n"
"Press J to create a new level!\n"
"**/\n"
"\n"
"const GRID_SIZE = 5;\n"
"\n"
"function checkGridSize() {\n"
"  if(GRID_SIZE > 5) console.error('Grid size cannot be greater than 5');\n"
"  if(GRID_SIZE < 3) console.error('Grid size cannot be less than 3');\n"
"  if(GRID_SIZE % 2 === 0) console.error('Grid size cannot be even');\n"
"};\n"
"\n"
"checkGridSize();\n"
"\n"
"/* PRNG: https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript */\n"
"function cyrb128(str) {\n"
"  let h1 = 1779033703,\n"
"    h2 = 3144134277,\n"
"    h3 = 1013904242,\n"
"    h4 = 2773480762;\n"
"  for (let i = 0, k; i < str.length; i++) {\n"
"    k = str.charCodeAt(i);\n"
"    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n"
"    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n"
"    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n"
"    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n"
"  }\n"
"  h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);\n"
"  h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);\n"
"  h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);\n"
"  h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);\n"
"  return [\n"
"    (h1 ^ h2 ^ h3 ^ h4) >>> 0,\n"
"    (h2 ^ h1) >>> 0,\n"
"    (h3 ^ h1) >>> 0,\n"
"    (h4 ^ h1) >>> 0,\n"
"  ];\n"
"}\n"
"\n"
"function sfc32(a, b, c, d) {\n"
"  return function () {\n"
"    a >>>= 0;\n"
"    b >>>= 0;\n"
"    c >>>= 0;\n"
"    d >>>= 0;\n"
"    var t = (a + b) | 0;\n"
"    a = b ^ (b >>> 9);\n"
"    b = (c + (c << 3)) | 0;\n"
"    c = (c << 21) | (c >>> 11);\n"
"    d = (d + 1) | 0;\n"
"    t = (t + d) | 0;\n"
"    c = (c + t) | 0;\n"
"    return (t >>> 0) / 4294967296;\n"
"  };\n"
"}\n"
"\n"
"const seed = cyrb128(String(Math.random()));\n"
"const prng = sfc32(seed[0], seed[1], seed[2], seed[3]);\n"
"\n"
"prng();\n"
"prng();\n"
"prng();\n"
"prng();\n"
"\n"
"/* Engine */\n"
"\n"
"class Pipe {\n"
"  constructor() {\n"
"    this.x = 0;\n"
"    this.y = 0;\n"
"\n"
"    this.active = 0;\n"
"\n"
"    this.UP = 0;\n"
"    this.RIGHT = 1;\n"
"    this.DOWN = 2;\n"
"    this.LEFT = 3;\n"
"\n"
"    this.connections = Array.apply(null, new Array(4)).map(\n"
"      Number.prototype.valueOf,\n"
"      0,\n"
"    );\n"
"  }\n"
"\n"
"  get isActive() {\n"
"    return this.active === 1 ? true : false;\n"
"  }\n"
"\n"
"  set isActive(active) {\n"
"    this.active = active ? 1 : 0;\n"
"  }\n"
"\n"
"  hasConnection(direction) {\n"
"    return this.connections[direction] === 1 ? true : false;\n"
"  }\n"
"\n"
"  rotate() {\n"
"    this.connections.splice(\n"
"      0,\n"
"      0,\n"
"      this.connections.splice(this.connections.length - 1, 1)[0],\n"
"    );\n"
"  }\n"
"}\n"
"\n"
"class Grid {\n"
"  constructor() {\n"
"    this.size = 0;\n"
"    this.pipes = [];\n"
"    this.win = false;\n"
"  }\n"
"\n"
"  init() {\n"
"    this.win = false;\n"
"    this.initPipes(GRID_SIZE);\n"
"    this.buildPipes();\n"
"    this.scramblePipes();\n"
"    this.checkPipes();\n"
"    this.draw();\n"
"  }\n"
"\n"
"  getPipe(x, y) {\n"
"    if (\n"
"      typeof this.pipes[x] !== 'undefined' &&\n"
"      typeof this.pipes[x][y] !== 'undefined'\n"
"    ) {\n"
"      return this.pipes[x][y];\n"
"    }\n"
"  }\n"
"\n"
"  initPipes(size) {\n"
"    this.size = size;\n"
"    for (let x = 1; x <= size; x++) {\n"
"      this.pipes[x] = [];\n"
"      for (let y = 1; y <= size; y++) {\n"
"        const pipe = new Pipe();\n"
"        pipe.x = x;\n"
"        pipe.y = y;\n"
"\n"
"        this.pipes[x][y] = pipe;\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  buildPipes() {\n"
"    const totalPipes = this.size * this.size;\n"
"    const connectedPipes = [];\n"
"\n"
"    const x = Math.ceil(this.size / 2);\n"
"    const y = Math.ceil(this.size / 2);\n"
"\n"
"    const firstPipe = this.pipes[x][y];\n"
"    firstPipe.active = 1;\n"
"\n"
"    connectedPipes.push(firstPipe);\n"
"\n"
"    while (connectedPipes.length < totalPipes) {\n"
"      const selected =\n"
"        connectedPipes[Math.floor(prng() * connectedPipes.length)];\n"
"      let newPipe = undefined;\n"
"\n"
"      // Create a random direction\n"
"      const direction = Math.floor(prng() * 4);\n"
"      let reverseDirection = undefined;\n"
"\n"
"      switch (direction) {\n"
"        case selected.UP: {\n"
"          let previousRow = this.pipes[selected.x - 1];\n"
"          if (typeof previousRow !== 'undefined') {\n"
"            newPipe = previousRow[selected.y];\n"
"          }\n"
"          reverseDirection = selected.DOWN;\n"
"          break;\n"
"        }\n"
"        case selected.DOWN: {\n"
"          let nextRow = this.pipes[selected.x + 1];\n"
"          if (typeof nextRow !== 'undefined') {\n"
"            newPipe = nextRow[selected.y];\n"
"          }\n"
"          reverseDirection = selected.UP;\n"
"          break;\n"
"        }\n"
"        case selected.RIGHT: {\n"
"          let bottomRow = this.pipes[selected.x];\n"
"          if (typeof bottomRow !== 'undefined') {\n"
"            newPipe = bottomRow[selected.y + 1];\n"
"          }\n"
"          reverseDirection = selected.LEFT;\n"
"          break;\n"
"        }\n"
"        case selected.LEFT: {\n"
"          let topRow = this.pipes[selected.x];\n"
"          if (typeof topRow !== 'undefined') {\n"
"            newPipe = topRow[selected.y - 1];\n"
"          }\n"
"          reverseDirection = selected.RIGHT;\n"
"          break;\n"
"        }\n"
"      }\n"
"\n"
"      if (\n"
"        typeof newPipe !== 'undefined' &&\n"
"        newPipe.connections.indexOf(1) === -1\n"
"      ) {\n"
"        selected.connections[direction] = 1;\n"
"        newPipe.connections[reverseDirection] = 1;\n"
"\n"
"        connectedPipes.push(newPipe);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  scramblePipes() {\n"
"    for (let x = 1; x < this.pipes.length; x++) {\n"
"      for (let y = 1; y < this.pipes.length; y++) {\n"
"        let pipe = this.pipes[x][y];\n"
"        let random = Math.floor(prng() * 4);\n"
"\n"
"        for (let i = 0; i < random; i++) {\n"
"          pipe.rotate();\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  disablePipes() {\n"
"    for (let x = 1; x < this.pipes.length; x++) {\n"
"      for (let y = 1; y < this.pipes.length; y++) {\n"
"        let pipe = this.pipes[x][y];\n"
"        pipe.isActive = false;\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  checkPipes() {\n"
"    let connectedPipes = [];\n"
"    let pipesToCheck = [];\n"
"\n"
"    // Disable all pipes\n"
"    this.disablePipes();\n"
"\n"
"    // Get the center pipe, set is to active, an add it to the set to be checked\n"
"    let centerPipe = this.getPipe(\n"
"      Math.ceil(this.size / 2),\n"
"      Math.ceil(this.size / 2),\n"
"    );\n"
"    centerPipe.isActive = true;\n"
"\n"
"    connectedPipes.push(centerPipe);\n"
"    pipesToCheck.push(centerPipe);\n"
"\n"
"    // While there are still pipes left to be checked\n"
"    while (pipesToCheck.length > 0) {\n"
"      let pipe = pipesToCheck.pop();\n"
"      let x = pipe.x;\n"
"      let y = pipe.y;\n"
"\n"
"      // Check if this pipe has a connection up\n"
"      if (pipe.hasConnection(pipe.UP)) {\n"
"        let above = this.getPipe(x - 1, y);\n"
"        if (\n"
"          typeof above !== 'undefined' &&\n"
"          above.hasConnection(pipe.DOWN) &&\n"
"          !above.isActive\n"
"        ) {\n"
"          above.isActive = true;\n"
"\n"
"          connectedPipes.push(above);\n"
"          pipesToCheck.push(above);\n"
"        }\n"
"      }\n"
"\n"
"      // Check if this pipe has a connection down\n"
"      if (pipe.hasConnection(pipe.DOWN)) {\n"
"        let below = this.getPipe(x + 1, y);\n"
"        if (\n"
"          typeof below !== 'undefined' &&\n"
"          below.hasConnection(pipe.UP) &&\n"
"          !below.isActive\n"
"        ) {\n"
"          below.isActive = true;\n"
"\n"
"          connectedPipes.push(below);\n"
"          pipesToCheck.push(below);\n"
"        }\n"
"      }\n"
"\n"
"      // Check if this pipe has a connection right\n"
"      if (pipe.hasConnection(pipe.RIGHT)) {\n"
"        let right = this.getPipe(x, y + 1);\n"
"        if (\n"
"          typeof right !== 'undefined' &&\n"
"          right.hasConnection(pipe.LEFT) &&\n"
"          !right.isActive\n"
"        ) {\n"
"          right.isActive = true;\n"
"\n"
"          connectedPipes.push(right);\n"
"          pipesToCheck.push(right);\n"
"        }\n"
"      }\n"
"\n"
"      // Check if the pipe has a connection left\n"
"      if (pipe.hasConnection(pipe.LEFT)) {\n"
"        let left = this.getPipe(x, y - 1);\n"
"        if (\n"
"          typeof left !== 'undefined' &&\n"
"          left.hasConnection(pipe.RIGHT) &&\n"
"          !left.isActive\n"
"        ) {\n"
"          left.isActive = true;\n"
"\n"
"          connectedPipes.push(left);\n"
"          pipesToCheck.push(left);\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    // Check if the user has won\n"
"    if (connectedPipes.length === this.size * this.size) {\n"
"      this.win = true;\n"
"      this.draw();\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"/* Utilities */\n"
"\n"
"function rotateText(text, rotation) {\n"
"  const rows = text.trim().split('\\n');\n"
"  const newRows = [];\n"
"\n"
"  const numRows = rows.length;\n"
"  const numItems = rows[0].length;\n"
"\n"
"  let x = 0;\n"
"  let y = 0;\n"
"  for (let i = 0; i < numItems; i++) {\n"
"    for (let j = numRows - 1; j > -1; j--) {\n"
"      const char = rows[j][i];\n"
"\n"
"      if (!newRows[y]) newRows[y] = [];\n"
"      newRows[y][x] = char;\n"
"\n"
"      x++;\n"
"    }\n"
"\n"
"    y++;\n"
"  }\n"
"\n"
"  const newText = newRows.map((row) => row.join('')).join('\\n');\n"
"  const currentRotation = rotation - 90;\n"
"\n"
"  if (currentRotation === 0) return newText;\n"
"  return rotateText(newText, currentRotation);\n"
"}\n"
"\n"
"function activeText(text) {\n"
"  return text.replace(/\\./g, '7');\n"
"}\n"
"\n"
"// https://bobbyhadz.com/blog/javascript-check-if-two-arrays-have-same-elements\n"
"function areArraysEqual(array1, array2) {\n"
"  if (array1.length === array2.length) {\n"
"    return array1.every((element) => {\n"
"      if (array2.includes(element)) {\n"
"        return true;\n"
"      }\n"
"\n"
"      return false;\n"
"    });\n"
"  }\n"
"\n"
"  return false;\n"
"}\n"
"\n"
"// https://stackoverflow.com/questions/5767325/how-can-i-remove-a-specific-item-from-an-array\n"
"function removeItemArray(arr, value) {\n"
"  var index = arr.indexOf(value);\n"
"  if (index > -1) {\n"
"    arr.splice(index, 1);\n"
"  }\n"
"  return arr;\n"
"}\n"
"\n"
"/* Sprig Implementation */\n"
"\n"
"const bentPipe = `\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....\n"
".....044440.....\n"
".....044440..000\n"
".....04444000040\n"
".....04444444040\n"
".....04444444040\n"
".....04444444040\n"
"......0444444040\n"
".......000000040\n"
".............000\n"
"................\n"
"................\n"
"................\n"
"................`;\n"
"\n"
"const crossPipe = `\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....\n"
".....044440.....\n"
"000..044440..000\n"
"0400004444000040\n"
"0404444444444040\n"
"0404444444444040\n"
"0404444444444040\n"
"0404444444444040\n"
"0400004444000040\n"
"000..044440..000\n"
".....044440.....\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....`;\n"
"\n"
"const endPipe = `\n"
"................\n"
"................\n"
"................\n"
"................\n"
"................\n"
"......0000......\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....`;\n"
"\n"
"const straightPipe = `\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
".....044440.....\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....`;\n"
"\n"
"const splitPipe = `\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....\n"
".....044440.....\n"
".....044440..000\n"
".....04444000040\n"
".....04444444040\n"
".....04444444040\n"
".....04444444040\n"
".....04444444040\n"
".....04444000040\n"
".....044440..000\n"
".....044440.....\n"
"....00000000....\n"
"....04444440....\n"
"....00000000....`;\n"
"\n"
"const pipeMap = new Map();\n"
"\n"
"const charList = 'abcdefghijklnopqrstuvwxyz1234567';\n"
"let charListPointer = -1;\n"
"\n"
"// End Points\n"
"pipeMap.set(['u'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(endPipe, 180)}`,\n"
"});\n"
"pipeMap.set(['d'], { code: charList[++charListPointer], sprite: `${endPipe}` });\n"
"pipeMap.set(['r'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(endPipe, 270)}`,\n"
"});\n"
"pipeMap.set(['l'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(endPipe, 90)}`,\n"
"});\n"
"\n"
"// Straight\n"
"pipeMap.set(['u', 'd'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${straightPipe}`,\n"
"});\n"
"pipeMap.set(['l', 'r'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(straightPipe, 90)}`,\n"
"});\n"
"\n"
"// Corners\n"
"pipeMap.set(['u', 'r'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${bentPipe}`,\n"
"});\n"
"pipeMap.set(['u', 'l'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(bentPipe, 270)}`,\n"
"});\n"
"pipeMap.set(['d', 'r'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(bentPipe, 90)}`,\n"
"});\n"
"pipeMap.set(['d', 'l'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(bentPipe, 180)}`,\n"
"});\n"
"\n"
"// Splits\n"
"pipeMap.set(['u', 'r', 'l'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(splitPipe, 270)}`,\n"
"});\n"
"pipeMap.set(['r', 'd', 'l'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(splitPipe, 90)}`,\n"
"});\n"
"pipeMap.set(['d', 'l', 'u'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${rotateText(splitPipe, 180)}`,\n"
"});\n"
"pipeMap.set(['u', 'r', 'd'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${splitPipe}`,\n"
"});\n"
"\n"
"// Cross\n"
"pipeMap.set(['u', 'r', 'd', 'l'], {\n"
"  code: charList[++charListPointer],\n"
"  sprite: `${crossPipe}`,\n"
"});\n"
"\n"
"const activePipeMap = new Map(pipeMap);\n"
"for (const key of activePipeMap.keys()) {\n"
"  const { sprite } = activePipeMap.get(key);\n"
"  activePipeMap.set(key, {\n"
"    code: charList[++charListPointer],\n"
"    sprite: activeText(sprite),\n"
"  });\n"
"}\n"
"\n"
"const legend = [];\n"
"for (const { code, sprite } of pipeMap.values()) {\n"
"  legend.push([code, bitmap`${sprite.trim()}`]);\n"
"}\n"
"\n"
"for (const { code, sprite } of activePipeMap.values()) {\n"
"  legend.push([code, bitmap`${sprite.trim()}`]);\n"
"}\n"
"\n"
"const m = 'm';\n"
"\n"
"setLegend(\n"
"  [\n"
"    '8',\n"
"    bitmap`\n"
"....222222222222\n"
"..22222222222222\n"
".222222222222222\n"
".222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222202220200\n"
"2222222202020220\n"
"2222222202020220\n"
"2222222202020220\n"
"2222222220002200\n"
"2222222222222222\n"
".222222222222222\n"
".222222222222222\n"
"..22222222222222\n"
"....222222222222`,\n"
"  ],\n"
"  [\n"
"    '9',\n"
"    bitmap`\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"0202202022022000\n"
"2202202022020222\n"
"2200202002020002\n"
"2202002020020222\n"
"0202202022022000\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222\n"
"2222222222222222`,\n"
"  ],\n"
"  [\n"
"    '0',\n"
"    bitmap`\n"
"222222222222....\n"
"22222222222222..\n"
"222222222222222.\n"
"222222222222222.\n"
"2222222222222222\n"
"2222222222222222\n"
"2200220222222222\n"
"2022020222222222\n"
"2000220222222222\n"
"2022022222222222\n"
"2022020222222222\n"
"2222222222222222\n"
"222222222222222.\n"
"222222222222222.\n"
"22222222222222..\n"
"222222222222....`,\n"
"  ],\n"
"  [\n"
"    m,\n"
"    bitmap`\n"
"0000000000000000\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0..............0\n"
"0000000000000000`,\n"
"  ],\n"
"  ...legend,\n"
");\n"
"\n"
"const solids = [];\n"
"for (const { code } of pipeMap.values(pipeMap)) {\n"
"  solids.push(code);\n"
"}\n"
"\n"
"setSolids(solids);\n"
"\n"
"let level = 0;\n"
"const levels = [\n"
"  map`\n"
".....\n"
".....\n"
".....\n"
".....\n"
".....`,\n"
"];\n"
"\n"
"setMap(levels[level].trim());\n"
"\n"
"let globalMouseX = 0;\n"
"let globalMouseY = 0;\n"
"\n"
"// Code Split for Clarity\n"
"class SprigGrid extends Grid {\n"
"  draw() {\n"
"    const tiles = getAll();\n"
"    for (const tile of tiles) {\n"
"      clearTile(tile.x, tile.y);\n"
"    }\n"
"\n"
"    for (let x in this.pipes) {\n"
"      let row = this.pipes[x];\n"
"      let rows = [];\n"
"\n"
"      for (let y in row) {\n"
"        let pipe = row[y];\n"
"        let pipeSymbol = [];\n"
"\n"
"        if (pipe.connections[0] === 1) pipeSymbol.push('u');\n"
"        if (pipe.connections[1] === 1) pipeSymbol.push('r');\n"
"        if (pipe.connections[2] === 1) pipeSymbol.push('d');\n"
"        if (pipe.connections[3] === 1) pipeSymbol.push('l');\n"
"        if (pipe.active === 1) pipeSymbol.push('a');\n"
"\n"
"        let code = '';\n"
"        const isActive = pipeSymbol.includes('a');\n"
"\n"
"        for (const key of pipeMap.keys()) {\n"
"          if (areArraysEqual(key, removeItemArray(pipeSymbol, 'a'))) {\n"
"            if (isActive) {\n"
"              ({ code } = activePipeMap.get(key));\n"
"            } else {\n"
"              ({ code } = pipeMap.get(key));\n"
"            }\n"
"          }\n"
"        }\n"
"\n"
"        addSprite(y - 1, x - 1, code);\n"
"      }\n"
"    }\n"
"\n"
"    addSprite(globalMouseX, globalMouseY, m);\n"
"\n"
"    if (grid.win) {\n"
"      addSprite((grid.size - 1) / 2 - 1, (grid.size - 1) / 2, '8');\n"
"      addSprite((grid.size - 1) / 2, (grid.size - 1) / 2, '9');\n"
"      addSprite((grid.size - 1) / 2 + 1, (grid.size - 1) / 2, '0');\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"const grid = new SprigGrid();\n"
"grid.init();\n"
"\n"
"function rotatePipe(x, y) {\n"
"  grid.getPipe(x + 1, y + 1).rotate();\n"
"  grid.checkPipes();\n"
"  grid.draw();\n"
"}\n"
"\n"
"onInput('w', () => {\n"
"  if (grid.win === true) return;\n"
"  getFirst(m).y -= 1;\n"
"  globalMouseY = getFirst(m).y;\n"
"});\n"
"\n"
"onInput('a', () => {\n"
"  if (grid.win === true) return;\n"
"  getFirst(m).x -= 1;\n"
"  globalMouseX = getFirst(m).x;\n"
"});\n"
"\n"
"onInput('s', () => {\n"
"  if (grid.win === true) return;\n"
"  getFirst(m).y += 1;\n"
"  globalMouseY = getFirst(m).y;\n"
"});\n"
"\n"
"onInput('d', () => {\n"
"  if (grid.win === true) return;\n"
"  getFirst(m).x += 1;\n"
"  globalMouseX = getFirst(m).x;\n"
"});\n"
"\n"
"onInput('l', () => {\n"
"  if (grid.win === true) return;\n"
"  const { x, y } = getFirst(m);\n"
"  rotatePipe(y, x);\n"
"});\n"
"\n"
"onInput('j', () => {\n"
"  grid.init();\n"
"});\n"
