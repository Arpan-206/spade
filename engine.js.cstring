"let setTimeout, setInterval, clearInterval, clearTimeout;\n"
"const {\n"
"  /* sprite interactions */ setSolids, setPushables,\n"
"  /*              see also: sprite.x +=, sprite.y += */\n"
"\n"
"  /* art */ setLegend, setBackground,\n"
"  /* text */ addText, clearText,\n"
"\n"
"  /*   spawn sprites */ setMap, addSprite,\n"
"  /* despawn sprites */ clearTile, /* sprite.remove() */\n"
"\n"
"  /* tile queries */ getGrid, getTile, getFirst, getAll, tilesWith,\n"
"  /* see also: sprite.type */\n"
"\n"
"  /* map dimensions */ width, height,\n"
"\n"
"  /* constructors */ bitmap, tune, map,\n"
"\n"
"  /* input handling */ onInput, afterInput,\n"
"\n"
"  /* how much sprite has moved since last onInput: sprite.dx, sprite.dy */\n"
"\n"
"  playTune,\n"
"} = (() => {\n"
"const exports = {};\n"
"/* re-exports from C; bottom of module_native.c has notes about why these are in C */\n"
"exports.setMap = map => native.setMap(map.trim());\n"
"exports.addSprite = native.addSprite;\n"
"exports.getGrid = native.getGrid;\n"
"exports.getTile = native.getTile;\n"
"exports.tilesWith = native.tilesWith;\n"
"exports.clearTile = native.clearTile;\n"
"exports.getFirst = native.getFirst;\n"
"exports.getAll = native.getAll;\n"
"exports.width = native.width;\n"
"exports.height = native.height;\n"
"exports.setBackground = native.setBackground;\n"
"\n"
"\n"
"/* opts: x, y, color (all optional) */\n"
"exports.addText = (str, opts={}) => {\n"
"  // console.log(\"engine.js:addText\");\n"
"  const CHARS_MAX_X = 21;\n"
"  const padLeft = Math.floor((CHARS_MAX_X - str.length)/2);\n"
"\n"
"  native.text_add(\n"
"    str,\n"
"    opts.color ?? [10, 10, 40],\n"
"    opts.x ?? padLeft,\n"
"    opts.y ?? 0\n"
"  );\n"
"}\n"
"\n"
"exports.clearText = () => native.text_clear();\n"
"\n"
"\n"
"exports.setLegend = (...bitmaps) => {\n"
"  // console.log(\"engine.js:setLegend\");\n"
"  native.legend_clear();\n"
"  for (const [charStr, bitmap] of bitmaps) {\n"
"    native.legend_doodle_set(charStr, bitmap.trim());\n"
"  }\n"
"  native.legend_prepare();\n"
"};\n"
"\n"
"exports.setSolids = solids => {\n"
"  // console.log(\"engine.js:setSolids\");\n"
"  native.solids_clear();\n"
"  solids.forEach(native.solids_push);\n"
"};\n"
"\n"
"exports.setPushables = pushTable => {\n"
"  // console.log(\"engine.js:setPushables\");\n"
"  native.push_table_clear();\n"
"  for (const [pusher, pushesList] of Object.entries(pushTable))\n"
"    for (const pushes of pushesList)\n"
"      native.push_table_set(pusher, pushes);\n"
"};\n"
"\n"
"let afterInputs = [];\n"
"// exports.afterInput = fn => (console.log('engine.js:afterInputs'), afterInputs.push(fn));\n"
"exports.afterInput = fn => afterInputs.push(fn);\n"
"\n"
"const button = {\n"
"  pinToHandlers: {\n"
"     \"5\": [],\n"
"     \"7\": [],\n"
"     \"6\": [],\n"
"     \"8\": [],\n"
"    \"12\": [],\n"
"    \"14\": [],\n"
"    \"13\": [],\n"
"    \"15\": [],\n"
"  },\n"
"  keyToPin: {\n"
"    \"w\":  \"5\",\n"
"    \"s\":  \"7\",\n"
"    \"a\":  \"6\",\n"
"    \"d\":  \"8\",\n"
"    \"i\": \"12\",\n"
"    \"k\": \"14\",\n"
"    \"j\": \"13\",\n"
"    \"l\": \"15\",\n"
"  }\n"
"};\n"
"\n"
"native.press_cb(pin => {\n"
"  button.pinToHandlers[pin].forEach(f => f());\n"
"\n"
"  afterInputs.forEach(f => f());\n"
"\n"
"  native.map_clear_deltas();\n"
"});\n"
"\n"
"{\n"
"  let timers = [];\n"
"  let id = 0;\n"
"  setTimeout  = (fn, ms) => (timers.push({ fn, ms, id }), id++);\n"
"  setInterval = (fn, ms) => (timers.push({ fn, ms, id, restartAt: ms }), id++);\n"
"  clearTimeout = clearInterval = id => {\n"
"    timers = timers.filter(t => t.id != id);\n"
"  };\n"
"  native.frame_cb(dt => {\n"
"    const errors = [];\n"
"\n"
"    timers = timers.filter(tim => {\n"
"      if (tim.ms <= 0) {\n"
"        /* trigger their callback */\n"
"        try {\n"
"          tim.fn();\n"
"        } catch (error) {\n"
"          if (error) errors.push(error)\n"
"        }\n"
"\n"
"        /* in case they cleared themselves */\n"
"        if (!timers.some(t => t == tim))\n"
"          return false;\n"
"\n"
"        /* restart intervals, clear timeouts */\n"
"        if (tim.restartAt !== undefined)\n"
"          tim.ms = tim.restartAt;\n"
"        else\n"
"          return false;\n"
"      }\n"
"      tim.ms -= dt;\n"
"      return true;\n"
"    });\n"
"\n"
"    /* who needs more than one error? -ced */\n"
"    if (errors.length) throw errors[0];\n"
"  });\n"
"}\n"
"\n"
"exports.onInput = (key, fn) => {\n"
"  // console.log(\"engine.js:onInput\");\n"
"  const pin = button.keyToPin[key];\n"
"\n"
"  if (pin === undefined)\n"
"    throw new Error(`the sprig doesn't have a \"${key}\" button!`);\n"
"\n"
"  button.pinToHandlers[pin].push(fn);\n"
"};\n"
"\n"
"exports.playTune = () => {};\n"
"\n"
"function _makeTag(cb) {\n"
"  return (strings, ...interps) => {\n"
"    if (typeof strings === \"string\") {\n"
"      throw new Error(\"Tagged template literal must be used like name`text`, instead of name(`text`)\");\n"
"    }\n"
"    const string = strings.reduce((p, c, i) => p + c + (interps[i] ?? ''), '');\n"
"    return cb(string);\n"
"  }\n"
"}\n"
"exports.bitmap = _makeTag(text => text);\n"
"exports.tune = _makeTag(text => text);\n"
"exports.map = _makeTag(text => text);\n"
"return exports;\n"
"})();\n"
"\n"
"/*\n"
"@title: gentle_gengar\n"
"@author: your_name\n"
"*/\n"
"\n"
"const player = \"p\";\n"
"\n"
"setLegend(\n"
"  [ player, bitmap`\n"
"................\n"
"................\n"
".......000......\n"
".......0.0......\n"
"......0..0......\n"
"......0...0.0...\n"
"....0003.30.0...\n"
"....0.0...000...\n"
"....0.05550.....\n"
"......0...0.....\n"
".....0....0.....\n"
".....0...0......\n"
"......000.......\n"
"......0.0.......\n"
".....00.00......\n"
"................`]\n"
");\n"
"\n"
"setSolids([]);\n"
"\n"
"let level = 0;\n"
"const levels = [\n"
"  map`\n"
"p.\n"
"..`,\n"
"];\n"
"\n"
"setMap(levels[level]);\n"
"\n"
"setPushables({\n"
"  [ player ]: [],\n"
"});\n"
"\n"
"onInput(\"w\", () => {\n"
"  getFirst(player).y -= 1\n"
"});\n"
"onInput(\"s\", () => {\n"
"  getFirst(player).y += 1\n"
"});\n"
"\n"
"// afterInput(() => {\n"
"//   throw new Error(\"oh no! i'm so scawed\");\n"
"// });\n"
"\n"
"let i = 0;\n"
"setInterval(() => {\n"
"  throw new Error(`hi ${++i}`)\n"
"}, 1000)\n"
