"let setTimeout, setInterval, clearInterval, clearTimeout;\n"
"const {\n"
"  /* sprite interactions */ setSolids, setPushables,\n"
"  /*              see also: sprite.x +=, sprite.y += */\n"
"\n"
"  /* art */ setLegend, setBackground,\n"
"  /* text */ addText, clearText,\n"
"\n"
"  /*   spawn sprites */ setMap, addSprite,\n"
"  /* despawn sprites */ clearTile, /* sprite.remove() */\n"
"\n"
"  /* tile queries */ getGrid, getTile, getFirst, getAll, tilesWith,\n"
"  /* see also: sprite.type */\n"
"\n"
"  /* map dimensions */ width, height,\n"
"\n"
"  /* constructors */ bitmap, tune, map,\n"
"\n"
"  /* input handling */ onInput, afterInput,\n"
"\n"
"  /* how much sprite has moved since last onInput: sprite.dx, sprite.dy */\n"
"\n"
"  playTune,\n"
"} = (() => {\n"
"const exports = {};\n"
"/* re-exports from C; bottom of module_native.c has notes about why these are in C */\n"
"exports.setMap = map => native.setMap(map.trim());\n"
"exports.addSprite = native.addSprite;\n"
"exports.getGrid = native.getGrid;\n"
"exports.getTile = native.getTile;\n"
"exports.tilesWith = native.tilesWith;\n"
"exports.clearTile = native.clearTile;\n"
"exports.getFirst = native.getFirst;\n"
"exports.getAll = native.getAll;\n"
"exports.width = native.width;\n"
"exports.height = native.height;\n"
"exports.setBackground = native.setBackground;\n"
"\n"
"\n"
"/* opts: x, y, color (all optional) */\n"
"exports.addText = (str, opts={}) => {\n"
"  console.log(\"engine.js:addText\");\n"
"  const CHARS_MAX_X = 21;\n"
"  const padLeft = Math.floor((CHARS_MAX_X - str.length)/2);\n"
"\n"
"  native.text_add(\n"
"    str,\n"
"    opts.color ?? [10, 10, 40],\n"
"    opts.x ?? padLeft,\n"
"    opts.y ?? 0\n"
"  );\n"
"}\n"
"\n"
"exports.clearText = () => native.text_clear();\n"
"\n"
"\n"
"exports.setLegend = (...bitmaps) => {\n"
"  console.log(\"engine.js:setLegend\");\n"
"  native.legend_clear();\n"
"  for (const [charStr, bitmap] of bitmaps) {\n"
"    native.legend_doodle_set(charStr, bitmap.trim());\n"
"  }\n"
"  native.legend_prepare();\n"
"};\n"
"\n"
"exports.setSolids = solids => {\n"
"  console.log(\"engine.js:setSolids\");\n"
"  native.solids_clear();\n"
"  solids.forEach(native.solids_push);\n"
"};\n"
"\n"
"exports.setPushables = pushTable => {\n"
"  console.log(\"engine.js:setPushables\");\n"
"  native.push_table_clear();\n"
"  for (const [pusher, pushesList] of Object.entries(pushTable))\n"
"    for (const pushes of pushesList)\n"
"      native.push_table_set(pusher, pushes);\n"
"};\n"
"\n"
"let afterInputs = [];\n"
"exports.afterInput = fn => (console.log('engine.js:afterInputs'), afterInputs.push(fn));\n"
"\n"
"const button = {\n"
"  pinToHandlers: {\n"
"     \"5\": [],\n"
"     \"7\": [],\n"
"     \"6\": [],\n"
"     \"8\": [],\n"
"    \"12\": [],\n"
"    \"14\": [],\n"
"    \"13\": [],\n"
"    \"15\": [],\n"
"  },\n"
"  keyToPin: {\n"
"    \"w\":  \"5\",\n"
"    \"s\":  \"7\",\n"
"    \"a\":  \"6\",\n"
"    \"d\":  \"8\",\n"
"    \"i\": \"12\",\n"
"    \"k\": \"14\",\n"
"    \"j\": \"13\",\n"
"    \"l\": \"15\",\n"
"  }\n"
"};\n"
"\n"
"native.press_cb(pin => {\n"
"  button.pinToHandlers[pin].forEach(f => f());\n"
"\n"
"  afterInputs.forEach(f => f());\n"
"\n"
"  native.map_clear_deltas();\n"
"});\n"
"\n"
"{\n"
"  let timers = [];\n"
"  let id = 0;\n"
"  setTimeout  = (fn, ms) => (timers.push({ fn, ms, id }), id++);\n"
"  setInterval = (fn, ms) => (timers.push({ fn, ms, id, restartAt: ms }), id++);\n"
"  clearTimeout = clearInterval = id => {\n"
"    timers = timers.filter(t => t.id != id);\n"
"  };\n"
"  native.frame_cb(dt_secs => {\n"
"    const dt = dt_secs * 1000;\n"
"    timers = timers.filter(tim => {\n"
"      if (tim.ms <= 0) {\n"
"        /* trigger their callback */\n"
"        tim.fn();\n"
"\n"
"        /* in case they cleared themselves */\n"
"        if (!timers.some(t => t == tim))\n"
"          return false;\n"
"\n"
"        /* restart intervals, clear timeouts */\n"
"        if (tim.restartAt !== undefined)\n"
"          tim.ms = tim.restartAt;\n"
"        else\n"
"          return false;\n"
"      }\n"
"      tim.ms -= dt;\n"
"      return true;\n"
"    });\n"
"  });\n"
"}\n"
"\n"
"exports.onInput = (key, fn) => {\n"
"  console.log(\"engine.js:onInput\");\n"
"  const pin = button.keyToPin[key];\n"
"\n"
"  if (pin === undefined)\n"
"    throw new Error(`the sprig doesn't have a \"${key}\" button!`);\n"
"\n"
"  button.pinToHandlers[pin].push(fn);\n"
"};\n"
"\n"
"exports.playTune = () => {};\n"
"\n"
"function _makeTag(cb) {\n"
"  return (strings, ...interps) => {\n"
"    if (typeof strings === \"string\") {\n"
"      throw new Error(\"Tagged template literal must be used like name`text`, instead of name(`text`)\");\n"
"    }\n"
"    const string = strings.reduce((p, c, i) => p + c + (interps[i] ?? ''), '');\n"
"    return cb(string);\n"
"  }\n"
"}\n"
"exports.bitmap = _makeTag(text => text);\n"
"exports.tune = _makeTag(text => text);\n"
"exports.map = _makeTag(text => text);\n"
"return exports;\n"
"})();\n"
"/*\n"
"@title: tetris\n"
"@author: neesh\n"
"*/\n"
"\n"
"const rows = 12;\n"
"const cols = 8;\n"
"const borders = false;\n"
"const emptyColor = \"0\";\n"
"\n"
"const iPiece = [\n"
"      [  true,  true,  true,  true ]\n"
"  ]\n"
"const jPiece = [\n"
"      [  true, false, false ],\n"
"      [  true,  true,  true ]\n"
"]\n"
"const lPiece = [\n"
"    [ false, false,  true ],\n"
"    [  true,  true,  true ]\n"
"]\n"
"const oPiece = [\n"
"    [  true,  true ],\n"
"    [  true,  true ]\n"
"]\n"
"const sPiece = [\n"
"    [ false,  true,  true ],\n"
"    [  true,  true, false ]\n"
"]\n"
"const tPiece = [\n"
"    [ false,  true, false ],\n"
"    [  true,  true,  true ]\n"
"]\n"
"const zPiece = [\n"
"    [  true,  true, false ],\n"
"    [ false,  true,  true ]\n"
"]\n"
"let board = [];\n"
"let score = 0;\n"
"const music = tune`\n"
"297.029702970297: e5-297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: b4-297.029702970297 + g4~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: c5-297.029702970297 + a4~297.029702970297 + d4~297.029702970297,\n"
"297.029702970297: d5-297.029702970297 + b4~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: c5-297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: b4-297.029702970297 + d4~297.029702970297,\n"
"297.029702970297: a4-297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: a4-297.029702970297 + f4~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: c5-297.029702970297 + a4~297.029702970297 + d4~297.029702970297,\n"
"297.029702970297: e5-297.029702970297 + c5~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: d5-297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: c5-297.029702970297 + d4~297.029702970297,\n"
"297.029702970297: b4-297.029702970297 + g4~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: c5-297.029702970297 + c4~297.029702970297 + a4~297.029702970297,\n"
"297.029702970297: d5-297.029702970297 + d4~297.029702970297 + b4~297.029702970297,\n"
"297.029702970297: c4~297.029702970297 + c5~297.029702970297 + e5-297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: d5-297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: a4-297.029702970297 + f4~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: a4-297.029702970297 + f4~297.029702970297 + c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297,\n"
"297.029702970297: c4~297.029702970297,\n"
"297.029702970297: d4~297.029702970297`\n"
"let playback = playTune(music, Infinity)\n"
"for (let i = 0; i < rows; i ++){\n"
"  const row = [];\n"
"  for (let j = 0; j < cols; j ++){ row.push(emptyColor); }\n"
"  board.push(row);\n"
"}\n"
"\n"
"const pieces = [ iPiece, jPiece, lPiece, oPiece,\n"
"                        sPiece, tPiece, zPiece ]\n"
"const colors = [ \"3\", \"6\", \"8\",\n"
"                             \"1\", \"7\", \"4\", \"5\" ]\n"
"\n"
"let fallingPiece;\n"
"let fallingPieceColor;\n"
"let numFallingPieceRows, numFallingPieceCols;\n"
"let fallingPieceRow, fallingPieceCol;\n"
"\n"
"function newFallingPiece() {\n"
"  let randomIndex = Math.floor(Math.random() * pieces.length);\n"
"  fallingPiece = pieces[randomIndex]\n"
"  fallingPieceColor = colors[randomIndex]\n"
"\n"
"  numFallingPieceRows = fallingPiece.length;\n"
"  numFallingPieceCols = fallingPiece[0].length;\n"
"  fallingPieceRow = 0;\n"
"  fallingPieceCol = Math.floor(cols / 2) - Math.floor(numFallingPieceCols / 2)\n"
"}\n"
"\n"
"function placeFallingPiece() {\n"
"  let fp = fallingPiece;\n"
"  for (let r = 0; r < fp.length; r ++) {\n"
"    const row = fp[r]\n"
"    for (let c = 0; c < fp[r].length; c++) {\n"
"      const col = fp[r][c];\n"
"      if (col) {\n"
"        let boardRow = fallingPieceRow + r;\n"
"        let boardCol = fallingPieceCol + c;\n"
"        board[boardRow][boardCol] = fallingPieceColor\n"
"      }\n"
"    }\n"
"  }\n"
"  removeFullRows()\n"
"}\n"
"\n"
"function generateEmpty2DList(rows, cols, fill) {\n"
"  const grid = [];\n"
"  for (let i = 0; i < rows; i ++) {\n"
"    const row = [];\n"
"    for (let j = 0; j < cols; j ++) {\n"
"      row.push(fill ? fill : \"\");\n"
"    }\n"
"    grid.push(row);\n"
"  }\n"
"  return grid\n"
"}\n"
"\n"
"function rotateFallingPiece() {\n"
"  const oldRows = numFallingPieceRows;\n"
"  const oldCols = numFallingPieceCols;\n"
"  const oldPiece = fallingPiece;\n"
"  const oldRow = fallingPieceRow;\n"
"  const oldCol = fallingPieceCol;\n"
"  let rotated = generateEmpty2DList(oldCols, oldRows)\n"
"\n"
"  let newRows = oldCols\n"
"  let newCols = oldRows\n"
"\n"
"  for (let c = 0; c < oldCols; c ++) {\n"
"    for (let r = 0; r < oldRows; r ++) {\n"
"      rotated[c][r] = oldPiece[r][c];\n"
"    }\n"
"  }\n"
"\n"
"  for (let r = 0; r < newRows; r ++) {\n"
"    rotated[r].reverse()\n"
"  }\n"
"\n"
"  numFallingPieceRows = newRows;\n"
"  numFallingPieceCols = newCols;\n"
"  fallingPiece = rotated;\n"
"\n"
"  let newRow = oldRow + Math.floor(oldRows / 2) - Math.floor(newRows / 2)\n"
"  let newCol = oldCol + Math.floor(oldCols / 2) - Math.floor(newCols / 2)\n"
"\n"
"  fallingPieceRow = newRow\n"
"  fallingPieceCol = newCol;\n"
"\n"
"  if(!fallingPieceIsLegal()) {\n"
"    fallingPiece = oldPiece;\n"
"    numFallingPieceRows = oldRows;\n"
"    numFallingPieceCols = oldCols;\n"
"    fallingPieceRow = oldRow;\n"
"    fallingPieceCol = oldCol;\n"
"  }\n"
"  \n"
"}\n"
"\n"
"function fallingPieceIsLegal() {\n"
"  for (let r = 0; r < fallingPiece.length; r ++) {\n"
"    const row = fallingPiece[r]\n"
"    for (let c = 0; c < row.length; c ++) {\n"
"      const col = fallingPiece[r][c];\n"
"      if (!col) continue;\n"
"      const x = r + fallingPieceRow;\n"
"      const y = c + fallingPieceCol;\n"
"      const withinBoundsX = x >= 0 && x < rows;\n"
"      const withinBoundsY = y >= 0 && y < cols;\n"
"      if (!withinBoundsX || !withinBoundsY) {\n"
"        return false;\n"
"      }\n"
"      if (board[x][y] != emptyColor) {\n"
"        return false\n"
"      }\n"
"    }\n"
"  }\n"
"  return true;\n"
"}\n"
"\n"
"function moveFallingPiece(drow, dcol) {\n"
"  fallingPieceRow += drow;\n"
"  fallingPieceCol += dcol;\n"
"  if (!fallingPieceIsLegal()) {\n"
"    fallingPieceRow -= drow;\n"
"    fallingPieceCol -= dcol;\n"
"    return false;\n"
"  }\n"
"  return true;\n"
"}\n"
"\n"
"function removeFullRows(app) {\n"
"  let fullRows = 0;\n"
"  const newBoard = [];\n"
"  board.forEach(row => {\n"
"    let isFull = true;\n"
"    row.forEach(col => {\n"
"      if (col == emptyColor) {\n"
"        isFull = false;\n"
"      }\n"
"    })\n"
"    if (isFull) {\n"
"      fullRows += 1;\n"
"    }\n"
"    else {\n"
"      newBoard.push(row)\n"
"    }\n"
"  })\n"
"  for (let r = 0; r < fullRows; r ++) {\n"
"    newBoard.splice(0, 0, Array.from(emptyColor.repeat(cols)))\n"
"  }\n"
"  board = newBoard\n"
"  score += fullRows;\n"
"}\n"
"\n"
"// each \"sprite\" contains 16 actual cells, x, y are the top left coords\n"
"function genPiece(xCoord, yCoord) {\n"
"  let sprite = []; // 4x4 of 4x4s\n"
"  for (let i = 0; i < 4; i ++) {\n"
"    let rows = []; // 4 4x4s\n"
"    for (let j = 0; j < 4; j ++){\n"
"      const x = i + xCoord;\n"
"      const y = j + yCoord;\n"
"      let cell = board[x][y];\n"
"      const withinFallingPieceX = fallingPieceRow <= x && x < fallingPieceRow + numFallingPieceRows\n"
"      const withinFallingPieceY = fallingPieceCol <= y && y < fallingPieceCol + numFallingPieceCols\n"
"      if (withinFallingPieceX && withinFallingPieceY) {\n"
"        if (fallingPiece[x - fallingPieceRow][y - fallingPieceCol]) {\n"
"          cell = fallingPieceColor;\n"
"        }\n"
"      }\n"
"      let row = []; // 4x4\n"
"      for (let r = 0; r < 4; r ++) {\n"
"        let miniRow = []; // 1x4\n"
"        for (let c = 0; c < 4; c ++) {\n"
"          if ((r == 0 || c == 0 || r == 3 || c == 3) && borders) { // make borders black\n"
"            miniRow.push(emptyColor);\n"
"          }\n"
"          else {\n"
"            miniRow.push(cell);\n"
"          }\n"
"        }\n"
"        row.push(miniRow);\n"
"      }\n"
"      rows.push(row)\n"
"    }\n"
"    sprite.push(rows);\n"
"  }\n"
"  return boardToString(sprite);\n"
"}\n"
"\n"
"function boardToString(board) {\n"
"  // board is a 4x4 of 4x4s\n"
"  let string = \"\";\n"
"  for (const bigRow of board) {\n"
"    let bigRowString = \"\\n\\n\\n\";\n"
"    for (const cell of bigRow) {\n"
"      // 4x4\n"
"      let row = \"\";\n"
"      for (let c = 0; c < 4; c ++) {\n"
"        for (let r = 0; r < 4; r ++) {\n"
"          row += (cell[r][c]);\n"
"        }\n"
"        row += \"\\n\"\n"
"      }\n"
"\n"
"      let rows = bigRowString.split(\"\\n\")\n"
"      let newRows = row.trim().split(\"\\n\")\n"
"      bigRowString = rows.map((r, i) => r + newRows[i]).join(\"\\n\")\n"
"    }\n"
"    string += bigRowString\n"
"    string += \"\\n\"\n"
"  }\n"
"  return string;\n"
"}\n"
"\n"
"\n"
"function loadPieces() {\n"
"  const legend = [];\n"
"  let i = 0;\n"
"  for (let r = 0; r < rows; r += 4){\n"
"    for (let c = 0; c < cols; c += 4) {\n"
"      legend.push([`${i}`, genPiece(r, c)])\n"
"      i += 1;\n"
"    }\n"
"  }\n"
"  setLegend(...legend)\n"
"}\n"
"\n"
"function start() {\n"
"  fallingPiece = undefined;\n"
"  fallingPieceRow = undefined;\n"
"  fallingPieceCol = undefined;\n"
"  fallingPieceColor = undefined;\n"
"  numFallingPieceRows = undefined;\n"
"  numFallingPieceCols = undefined;\n"
"\n"
"  board = generateEmpty2DList(rows, cols, emptyColor)\n"
"  newFallingPiece();\n"
"  loadPieces();\n"
"  score = 0;\n"
"}\n"
"\n"
"\n"
"start();\n"
"setBackground(bitmap`\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000\n"
"0000000000000000`);\n"
"\n"
"setMap(`\n"
"01\n"
"23\n"
"45\n"
"`)\n"
"\n"
"setSolids([]);\n"
"\n"
"setInterval(() => {\n"
"  getAll().forEach((sprite) => {\n"
"    sprite.remove();\n"
"  })\n"
"  loadPieces();\n"
"  setMap(`\n"
"  01\n"
"  23\n"
"  45\n"
"  `)\n"
"\n"
"  clearText();\n"
"  addText(`${score}`, { x: 14, y: 1, color: [255, 255, 255] })\n"
"}, 30)\n"
"\n"
"setInterval(() => {\n"
"  if (!moveFallingPiece(1, 0)) {\n"
"    placeFallingPiece();\n"
"    newFallingPiece();\n"
"  }\n"
"\n"
"  for (let c = 0; c < cols; c ++) {\n"
"    if (board[0][c] != emptyColor) {\n"
"      start();\n"
"    }\n"
"  }\n"
"}, 700)\n"
"\n"
"onInput(\"d\", () => { moveFallingPiece(0, 1) })\n"
"onInput(\"a\", () => { moveFallingPiece(0, -1) })\n"
"onInput(\"s\", () => { moveFallingPiece(1, 0) })\n"
"onInput(\"w\", () => { rotateFallingPiece() })\n"
"onInput(\"k\", () => { start() })\n"
"\n"
